//Методы массивов, функций, объектов, коллекций

// некоторые методы массивов
let a = [1, 2, 3, 4, 5]
let b = [6, 7, 8]

c = a.concat(b).concat(0) // concat соединяет два массива в один и возвращает новый массив. Также может добавить значение, а не массив

console.log(c);

console.log(c.every((el) => {return el < 10})); //every проверяет условие для каждого элемента (вернет true, если условие верно для каждого)

console.log(c.find((el) => {return el % 4 == 0})); //find находит первый элемент массива, удовлетворяющего условию

c.forEach(el => { // forEach применяет функцию-аргумент к каждому элементу массива
    console.log(el**2);
});

d = c.filter((el) => {return el % 2 == 0}) // filter возвращает массив, состоящий из элементов другого массива, удовлетворяющего условию
console.log(d);

e = c.map((el) => {return el ** 3}) // map возвращает массив, полученный с помощью применения функции-аргумента к каждому элементу исходного массива
console.log(e);

f = c.sort()
console.log(f); // sort сортирует массив и возвращает новый

//некоторые методы функций
function func (arg){
    console.log(arg);
}

func.call(this, 5) // call вызывает функцию, контекст которой передается первым аргументом, вторым и последующим - аргументы

func.apply(this, [5]) // apply работает как и call, но аргументы в функцию передаются массивом, а не отдельными аргументами

func2 = func.bind(this, 7) // bind создает новую функцию с настроенным контекстом и переданными аргументами
func2()

//некоторые методы объектов

me = {
    name: "Egor",
    surname: "Krivoshlykov",
    age: 20,
    sayHi: () => {console.log('Hello');}
}

console.log(me.toString()); // toString - универсальный метод. Он возвращает строковое представление любого переданного аргумента.
me.sayHi() // методы объекта, описанные программистом, тоже методы

console.log(Object.keys(me));  // keys возвращает ключи (имена) полей объекта

smb = Object.create(me); // create создает объект с прототипом в виде объекта-аргумента
Object.entries(me).forEach((el) => {console.log(el);}) // entries возвращает пары ключ-значение для объекта

//некоторые методы коллекций

a = [1, 5, 4, 7, 8]
s = new Set([1, 2, 5, 4, 2, 1])
m = new Map([[1, 2], [3, 4], [5, 6], [7, 8]])

console.log(m);

//методы, показанные для массива, применимы и к коллекции (по сути, массив это тоже коллекция)

s.add(100) // add добавляет уникальное значение в Set

console.log(m.get(1)); // Map.get возвращает значение по ключу-аргументу
console.log(m.has(8)); // Map.has проверяет, есть ли такой ключ в ключах map-объекта

//Стрелочные и обычные функции
//отличием стрелочной функции от обычной является отсутствие собственного контекста (this). Также у стрелочной функции нет магического объекта arguments. К стрелочным функциям неприменим оператор new.
function f1(arg1, arg2){
    console.log(arguments); // выведется словарь номер_аргумента - значение
    console.log(this.name);
}

f1.call({name: 'Egor'}, 1, 2) //Egor

f2 = (arg1, arg2) => {
    console.log(this.name); 
    //console.log(arguments); - аргументы не выведутся на экран. У стрелочной функции этого объекта нет.
}
f2.call({name: 'Egor'}) //Undefined - у стрелочной функции нет контекста

f3 = new f1() // создастся новая функция
//f4 = new f2() - Error

//Замыкание
function closure(name, age){
    function inner(){
        console.log(`${name} is ${age} y.o.`);
        return {name: name, age: age}
    }
    return inner
}

callInfo = closure('Egor', 20)
console.log(callInfo()); 

//Замыкание примечательно тем, что inner-функция сохраняет доступ к тем параметрам, что мы передали при вызове closure-функции. Эта особенность применяется, к примеру, в коллбэк-методах

//sread, rest, destruction

//spread - распаковка объекта

arr1 = [1, 2, 3]
arr2 = [...arr1, 5, 6] //spread позволяет разложить (распылить) объект на его составные части (элементы). В случае массива это его элементы

console.log(arr2);

//rest - остаток

const [num1, num2, num3] = arr1 //array destruction. Разбивает массив на элементы, и соотносит их с элементами, которым присваивается результат
//если элементов меньше, чем значений в массиве, что неиспользованные значения никуда не поместятся
console.log(num2);

const [num4, ...num5] = arr1 //num5 является rest массивом. Иначе, остатком. В него помещается (в виде коллекции) все то, что не вошло в предыдущие элементы
console.log(num5);

const {name, age} = me //деструктуризация объекта. Работает точно так же, как и для массива, к полям обращается по ключам, указанным в качестве переменных в []
console.log(name); //Egor
console.log(age); //20

const {sayHi, ...rest} = me
console.log(rest); //остаток объекта - имя, фамилия, возраст. Функция осталась в переменной sayHi

//Классы
//Классом по сути называется пользовательский тип данных, содержащий свои поля и методы

class MyClass{
    constructor(value){             //конструктор класса - метод, создающий инстанс класса
        this.value = value
    }
    countResult(){
        this.result = this.value ** 2
    }
    getValue(){
        return this.value
    } 
    getResut(){
        return this.result
    }
}

const myObj = new MyClass(5) // вызвался конструктор
myObj.countResult();
console.log(myObj.getResut());

//Классы являются основой ООП. Принципами ООП являются инкапсуляция, наследование и полиморфизм.
//Инкапсуляцией называется скрытие некотрых свойств класса (использование private и protected методов и полей, в JS реализовано слабо)
//Наследованием называется возможность создать новый класс, который унаследует все методы своего родителя.

class Child extends MyClass{
    countResult(){
        this.result = this.value ** 3
    }
    sayInfo(){
        this.countResult();
        console.log(`Result: ${this.result}`);
    }
}

const child = new Child(5)
child.sayInfo()

//Использовав наследование (extends), можно как дополнить класс методами, так и переопределить существующие

//Полиморфизмом называется возможность объектов иметь разное поведение в одинаковых ситуациях. Частным случаем являются перегрузки методов
const objects = [myObj, child]
objects.forEach((el) => {
    el.countResult()
    console.log(el.result);
})

//в примере выше мы не знаем, что за класс породил el. Но знаем, что оба класса имеют метод countResult. И, за счет этого, получили разное поведение (полиморфность).

//классический механизм наследования в js используется редко, поскольку в js есть прототипное наследование. За счет свойства объектов object.prototype мы можем
//получить информацию о том, какой объект был прототипом (фактически, родителем) данного. У всех объектов и примитивов js один общий прототип - null.